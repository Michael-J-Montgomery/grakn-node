const grpc = require("grpc");
const messages = require("./autogenerated/grakn_pb");
const conceptMessages = require("./autogenerated/concept_pb");
const services = require("./autogenerated/grakn_grpc_pb");
const ConceptFactory = require("./ConceptFactory");
const AsyncBlockingQueue = require("./util/AsyncBlockingQueue");

function GraknClient(uri, keyspace, credentials) {
  this.client = new services.GraknClient(
    uri,
    grpc.credentials.createInsecure()
  );
  this.keyspace = keyspace;
  this.credentials = credentials;
  this.stream = null;
  this.response = new AsyncBlockingQueue();
  this.result = [];
}

function executeQuery(query, stream) {
  const txRequest = new messages.TxRequest();
  const executeQuery = new messages.ExecQuery();
  const queryRequest = new messages.Query();
  queryRequest.setValue(query);
  executeQuery.setQuery(queryRequest);
  txRequest.setExecquery(executeQuery);
  stream.write(txRequest);
}

function openTx(duplex, keyspace, credentials) {
  return new Promise((resolve, reject) => {
    const openRequest = new messages.Open();
    const txRequest = new messages.TxRequest();
    const messageKeyspace = new messages.Keyspace();
    messageKeyspace.setValue(keyspace);

    openRequest.setKeyspace(messageKeyspace);
    openRequest.setTxtype(messages.TxType.WRITE);
    openRequest.setUsername(credentials.username);
    openRequest.setPassword(credentials.password);
    txRequest.setOpen(openRequest);

    duplex.write(txRequest);

    this.response.pop().then(() => {});
  });
}

GraknClient.prototype._setResponse = function(resp) {
  this.response.add(resp);
};

/**
 * Blocking code that waits for a response from server
 */
GraknClient.prototype._getResponse = function() {
  return this.response.pop();
};

GraknClient.prototype._executeQueryCb = function executeQueryCb(
  resolve,
  reject
) {
  this.response.pop().then(resp => {
    if (resp.hasDone()) {
      const currentResult = this.result;
      this.result = [];
      return resolve(currentResult);
    } else if (resp.hasIteratorid()) {
      const nr = new messages.Next();
      nr.setIteratorid(resp.getIteratorid());
      const tr = new messages.TxRequest();
      tr.setNext(nr);
      this.nextRequest = tr;
      this._getNextResult();
    } else if (resp.hasQueryresult()) {
      this._parseResult(resp.getQueryresult());
      this._getNextResult();
    }
  });
};

GraknClient.prototype._getNextResult = function() {
  this.stream.write(this.nextRequest);
};

GraknClient.prototype._parseResult = function(queryResult) {
  const prova = conceptMessages.BaseType.RelationshipType;
  if (queryResult.hasOtherresult()) {
    // compute or aggregate query
    this.result = JSON.parse(queryResult.getOtherresult());
  } else {
    const grpcMap = queryResult.getAnswer().getAnswerMap();
    const answerMap = new Map();
    grpcMap.forEach((grpcConcenpt, key) => {
      answerMap.set(
        key,
        ConceptFactory.createConcept(grpcConcenpt, this.stream)
      );
    });
    this.result.push(answerMap);
  }
};

GraknClient.prototype._initStream = function() {
  this.stream = this.client.tx();
  this.stream.on("data", resp => {
    this.response.add(resp);
  });

  duplex.on("end", () => {
    console.log("Stream from server terminated.");
  });

  duplex.on("error", err => {
    console.log("BAD ERROR: " + err);
  });

  // call.on('end', () => {
  //     // probably delete some iterators?
  // })

  // call.on('status', () => {
  //     // do we need this callback?
  // })
  return openTx(this.stream, this.keyspace, this.credentials);
};

GraknClient.prototype.execute = function execute(query) {
  return new Promise((resolve, reject) => {
    if (!this.stream) {
      this._initStream().then(() => {
        executeQuery(query, this.stream);
        this._executeQueryCb(resolve, reject);
      });
    } else {
      executeQuery(query, this.stream);
      this._executeQueryCb(resolve, reject);
    }
  });
};

module.exports = GraknClient;
